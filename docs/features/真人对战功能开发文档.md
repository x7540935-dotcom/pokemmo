# 真人对战功能开发文档

## 目录

- [功能概述](#功能概述)
- [架构设计](#架构设计)
- [实现方案](#实现方案)
- [技术细节](#技术细节)
- [开发步骤](#开发步骤)
- [测试计划](#测试计划)
- [后续优化](#后续优化)

---

## 功能概述

### 功能描述

真人对战功能允许两个真实玩家通过 WebSocket 连接进行实时宝可梦对战。与AI对战不同，真人对战需要：
- 两个玩家同时连接
- 双方都发送自己的队伍
- 双方都进行实时选择（技能、换人）
- 同步对战状态

### 功能特性

1. **双人匹配**
   - 玩家1创建房间或加入房间
   - 玩家2加入房间
   - 双方确认后开始对战

2. **实时对战**
   - 基于 WebSocket 的实时通信
   - 同步对战状态
   - 支持技能选择、换人等操作

3. **队伍管理**
   - 双方使用各自的队伍
   - 队伍验证和格式检查

4. **对战结束**
   - 胜负判断
   - 对战结果统计
   - 重赛选项

---

## 架构设计

### 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                   玩家1 (Browser)                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │  BattleEngine (WebSocket Client)                │   │
│  │  - 连接到服务器                                  │   │
│  │  - 发送队伍数据                                  │   │
│  │  - 接收协议消息                                  │   │
│  │  - 发送选择命令                                  │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          ↕ WebSocket
┌─────────────────────────────────────────────────────────┐
│                  Battle Server                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │  battle-server.js                               │   │
│  │  - 管理WebSocket连接                            │   │
│  │  - 房间管理                                      │   │
│  │  - 匹配玩家                                      │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │  BattleManager (mode: 'pvp')                    │   │
│  │  - 创建对战实例                                  │   │
│  │  - 管理两个PlayerChoiceHandler                  │   │
│  │  - 路由协议消息                                  │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Pokemon Showdown BattleStream                  │   │
│  │  - 对战引擎                                      │   │
│  │  - 协议生成                                      │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          ↕ WebSocket
┌─────────────────────────────────────────────────────────┐
│                   玩家2 (Browser)                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │  BattleEngine (WebSocket Client)                │   │
│  │  - 连接到服务器                                  │   │
│  │  - 发送队伍数据                                  │   │
│  │  - 接收协议消息                                  │   │
│  │  - 发送选择命令                                  │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 数据流

1. **连接阶段**
   ```
   玩家1 → 服务器: 创建房间/加入房间
   玩家2 → 服务器: 加入房间
   服务器 → 玩家1, 玩家2: 房间状态更新
   ```

2. **队伍提交阶段**
   ```
   玩家1 → 服务器: 发送队伍数据
   玩家2 → 服务器: 发送队伍数据
   服务器 → 玩家1, 玩家2: 双方队伍确认
   ```

3. **对战阶段**
   ```
   服务器 → 玩家1, 玩家2: 协议消息（队伍预览、对战状态等）
   玩家1 → 服务器: 选择命令（技能/换人）
   玩家2 → 服务器: 选择命令（技能/换人）
   服务器 → 玩家1, 玩家2: 协议消息（对战结果）
   ```

---

## 实现方案

### 1. 房间系统

#### 房间数据结构

```javascript
class Room {
  constructor(roomId, creator) {
    this.roomId = roomId;           // 房间ID
    this.creator = creator;         // 创建者WebSocket连接
    this.players = {};              // { p1: ws, p2: ws }
    this.teams = {};                // { p1: team, p2: team }
    this.status = 'waiting';        // 'waiting' | 'ready' | 'battling' | 'ended'
    this.battleManager = null;      // BattleManager实例
    this.createdAt = Date.now();    // 创建时间
  }
}
```

#### 房间管理（RoomManager）

```javascript
const RoomManager = require('../domain/rooms/RoomManager');
const roomManager = new RoomManager();

// battle-server.js / controllers/PvPController.js
function handleCreateRoom(ws) {
  const room = roomManager.createRoom(ws);
  if (!room) throw new Error('room creation failed');
  room.addPlayer('p1', ws);
  return room;
}

function handleJoinRoom(ws, roomId) {
  const room = roomManager.joinRoom(roomId, ws);
  if (!room) throw new Error('room not available');
  return room;
}

// runtime stats（健康检查与诊断使用）
const stats = roomManager.getStats();
// => { totalRooms, waitingRooms, battlingRooms, roomsWithOpenSlot, players: { total, waiting } }
```

### 2. 消息协议

#### 客户端 → 服务器

```javascript
// 创建房间
{
  type: 'create-room',
  payload: {}
}

// 加入房间
{
  type: 'join-room',
  payload: {
    roomId: 'ABC123'
  }
}

// 开始对战
{
  type: 'start',
  payload: {
    mode: 'pvp',
    formatid: 'gen9ou',
    team: [...],  // 队伍数据
    roomId: 'ABC123'
  }
}

// 选择命令
{
  type: 'choose',
  payload: {
    command: 'move 1'  // 或 'switch 2'
  }
}
```

#### 服务器 → 客户端

```javascript
// 房间创建成功
{
  type: 'room-created',
  payload: {
    roomId: 'ABC123'
  }
}

// 房间状态更新
{
  type: 'room-update',
  payload: {
    roomId: 'ABC123',
    status: 'waiting' | 'ready' | 'battling',
    players: {
      p1: { connected: true, teamReady: false },
      p2: { connected: false, teamReady: false }
    }
  }
}

// 对战协议（Pokemon Showdown格式）
'|poke|p1|Charizard, L50, F|'
'|request|{...}|'
'|win|p1|'
```

### 3. BattleManager 集成

#### 初始化真人对战

```javascript
// BattleManager.js
async initialize(team1, team2, formatid = 'gen9ou', seed = null) {
  // ... 创建对战引擎 ...
  
  // 创建处理器
  if (this.mode === 'pvp') {
    // 真人对战：两个玩家处理器
    this.handlers.p1 = new PlayerChoiceHandler(streams.p1);
    this.handlers.p2 = new PlayerChoiceHandler(streams.p2);
  } else if (this.mode === 'ai') {
    // AI对战：一个玩家处理器，一个AI处理器
    this.handlers.p1 = new PlayerChoiceHandler(streams.p1);
    this.handlers.p2 = new AIChoiceHandler(streams.p2, this.options.difficulty);
  }
  
  // ... 创建协议路由 ...
}
```

#### 连接玩家

```javascript
connectPlayer(side, ws) {
  this.connections[side] = ws;
  this.handlers[side].setConnection(ws);
  
  // 设置消息处理
  ws.on('message', (data) => {
    try {
      const message = JSON.parse(data.toString());
      if (message.type === 'choose') {
        this.handlers[side].handleChoice(message.payload.command);
      }
    } catch (e) {
      console.error(`[BattleManager] 解析消息失败:`, e);
    }
  });
  
  // 开始发送协议
  this.router.start();
}
```

### 4. 前端实现

#### 房间创建/加入界面

```html
<!-- pvp-lobby.html -->
<div id="lobby">
  <h2>真人对战大厅</h2>
  
  <!-- 创建房间 -->
  <div id="create-room">
    <button onclick="createRoom()">创建房间</button>
    <div id="room-id-display" style="display: none;">
      <p>房间ID: <span id="room-id"></span></p>
      <p>等待玩家加入...</p>
    </div>
  </div>
  
  <!-- 加入房间 -->
  <div id="join-room">
    <input type="text" id="room-id-input" placeholder="输入房间ID">
    <button onclick="joinRoom()">加入房间</button>
  </div>
  
  <!-- 房间状态 -->
  <div id="room-status" style="display: none;">
    <p>玩家1: <span id="player1-status">未准备</span></p>
    <p>玩家2: <span id="player2-status">未准备</span></p>
    <button id="start-battle-btn" onclick="startBattle()" disabled>开始对战</button>
  </div>
</div>
```

#### 前端逻辑

```javascript
// pvp-lobby.js
let currentRoomId = null;
let engine = null;

async function createRoom() {
  engine = new BattleEngine();
  await engine.connect();
  
  engine.send({
    type: 'create-room',
    payload: {}
  });
  
  engine.on('message', (data) => {
    const message = JSON.parse(data);
    if (message.type === 'room-created') {
      currentRoomId = message.payload.roomId;
      document.getElementById('room-id').textContent = currentRoomId;
      document.getElementById('room-id-display').style.display = 'block';
    } else if (message.type === 'room-update') {
      updateRoomStatus(message.payload);
    }
  });
}

async function joinRoom() {
  const roomId = document.getElementById('room-id-input').value;
  engine = new BattleEngine();
  await engine.connect();
  
  engine.send({
    type: 'join-room',
    payload: { roomId }
  });
  
  engine.on('message', (data) => {
    const message = JSON.parse(data);
    if (message.type === 'room-update') {
      updateRoomStatus(message.payload);
    }
  });
}

function startBattle() {
  const team = loadTeamFromStorage();
  engine.startBattle({
    mode: 'pvp',
    formatid: 'gen9ou',
    team: team,
    roomId: currentRoomId
  });
}
```

---

## 技术细节

### 1. 房间ID生成

```javascript
function generateRoomId() {
  // 生成6位随机字符串（字母+数字）
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let roomId = '';
  for (let i = 0; i < 6; i++) {
    roomId += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return roomId;
}
```

### 2. 房间状态管理

```javascript
class RoomManager {
  constructor() {
    this.rooms = new Map();
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, 60000); // 每分钟清理一次
  }
  
  createRoom(ws) {
    const roomId = generateRoomId();
    const room = new Room(roomId, ws);
    this.rooms.set(roomId, room);
    
    // 设置超时（10分钟无活动自动删除）
    room.timeout = setTimeout(() => {
      this.deleteRoom(roomId);
    }, 10 * 60 * 1000);
    
    return room;
  }
  
  joinRoom(roomId, ws) {
    const room = this.rooms.get(roomId);
    if (!room || room.status !== 'waiting') {
      return null;
    }
    
    // 分配side
    if (!room.players.p1) {
      room.players.p1 = ws;
      ws._side = 'p1';
    } else if (!room.players.p2) {
      room.players.p2 = ws;
      ws._side = 'p2';
    } else {
      return null; // 房间已满
    }
    
    // 清除超时
    if (room.timeout) {
      clearTimeout(room.timeout);
    }
    
    return room;
  }
  
  cleanup() {
    const now = Date.now();
    for (const [roomId, room] of this.rooms.entries()) {
      // 删除超过30分钟的空房间
      if (room.status === 'waiting' && now - room.createdAt > 30 * 60 * 1000) {
        this.deleteRoom(roomId);
      }
    }
  }
  
  deleteRoom(roomId) {
    const room = this.rooms.get(roomId);
    if (room) {
      // 通知玩家房间已关闭
      if (room.players.p1) {
        room.players.p1.send(JSON.stringify({
          type: 'room-closed',
          payload: { reason: 'timeout' }
        }));
      }
      if (room.players.p2) {
        room.players.p2.send(JSON.stringify({
          type: 'room-closed',
          payload: { reason: 'timeout' }
        }));
      }
      
      // 清理BattleManager
      if (room.battleManager) {
        room.battleManager.destroy();
      }
      
      this.rooms.delete(roomId);
    }
  }
}
```

### 3. 队伍验证

```javascript
function validateTeam(team) {
  // 检查队伍数量
  if (!Array.isArray(team) || team.length === 0 || team.length > 6) {
    return { valid: false, error: '队伍数量必须在1-6之间' };
  }
  
  // 检查每个宝可梦
  for (const pokemon of team) {
    if (!pokemon.species) {
      return { valid: false, error: '宝可梦缺少species字段' };
    }
    
    // 检查技能数量
    if (pokemon.moves && pokemon.moves.length > 4) {
      return { valid: false, error: '每个宝可梦最多4个技能' };
    }
  }
  
  return { valid: true };
}
```

### 4. 错误处理

```javascript
// 连接断开处理
ws.on('close', () => {
  const room = findRoomByConnection(ws);
  if (room) {
    // 通知另一个玩家
    const otherSide = ws._side === 'p1' ? 'p2' : 'p1';
    if (room.players[otherSide]) {
      room.players[otherSide].send(JSON.stringify({
        type: 'opponent-disconnected',
        payload: {}
      }));
    }
    
    // 清理房间
    if (room.battleManager) {
      room.battleManager.destroy();
    }
    
    deleteRoom(room.roomId);
  }
});
```

---

## 开发步骤

### 阶段1：后端基础功能（1-2天）

1. **实现房间系统**
   - [ ] 创建 `Room` 类
   - [ ] 创建 `RoomManager` 类
   - [ ] 实现房间创建/加入逻辑
   - [ ] 实现房间状态管理

2. **扩展 BattleManager**
   - [ ] 支持 `pvp` 模式初始化
   - [ ] 实现双玩家连接
   - [ ] 实现协议路由到两个玩家

3. **扩展 battle-server.js**
   - [ ] 处理 `create-room` 消息
   - [ ] 处理 `join-room` 消息
   - [ ] 处理 `start` 消息（pvp模式）
   - [ ] 实现房间查找和清理

### 阶段2：前端基础功能（1-2天）

1. **创建房间大厅页面**
   - [ ] 创建 `pvp-lobby.html`
   - [ ] 实现房间创建UI
   - [ ] 实现房间加入UI
   - [ ] 实现房间状态显示

2. **扩展 BattleEngine**
   - [ ] 支持房间相关消息
   - [ ] 实现房间状态监听
   - [ ] 实现对战启动

3. **更新主页**
   - [ ] 添加"真人对战"按钮
   - [ ] 跳转到房间大厅

### 阶段3：对战功能（2-3天）

1. **完善对战流程**
   - [ ] 实现队伍提交和验证
   - [ ] 实现双方确认机制
   - [ ] 实现对战开始
   - [ ] 实现协议同步

2. **错误处理**
   - [ ] 处理连接断开
   - [ ] 处理房间超时
   - [ ] 处理无效命令
   - [ ] 处理对战中断

3. **测试和调试**
   - [ ] 单元测试
   - [ ] 集成测试
   - [ ] 端到端测试

### 阶段4：优化和增强（1-2天）

1. **用户体验优化**
   - [ ] 添加加载动画
   - [ ] 添加错误提示
   - [ ] 优化UI响应速度

2. **功能增强**
   - [ ] 添加观战功能（可选）
   - [ ] 添加对战回放（可选）
   - [ ] 添加统计功能（可选）

---

## 测试计划

### 单元测试

1. **房间管理测试**
   ```javascript
   test('创建房间', () => {
     const room = roomManager.createRoom(ws1);
     expect(room.roomId).toBeDefined();
     expect(room.status).toBe('waiting');
   });
   
   test('加入房间', () => {
     const room = roomManager.createRoom(ws1);
     const result = roomManager.joinRoom(room.roomId, ws2);
     expect(result).toBe(room);
     expect(room.players.p2).toBe(ws2);
   });
   ```

2. **队伍验证测试**
   ```javascript
   test('验证有效队伍', () => {
     const team = [{ species: 'Pikachu', moves: ['Thunderbolt'] }];
     const result = validateTeam(team);
     expect(result.valid).toBe(true);
   });
   
   test('验证无效队伍', () => {
     const team = [];
     const result = validateTeam(team);
     expect(result.valid).toBe(false);
   });
   ```

### 集成测试

1. **完整对战流程测试**
   - 两个玩家创建/加入房间
   - 双方提交队伍
   - 开始对战
   - 双方进行选择
   - 对战结束

2. **错误场景测试**
   - 连接断开
   - 房间超时
   - 无效命令
   - 对战中断

### 端到端测试

1. **双浏览器测试**
   - 使用两个浏览器窗口
   - 模拟两个玩家
   - 测试完整对战流程

2. **网络延迟测试**
   - 模拟网络延迟
   - 测试协议同步
   - 测试重连机制

---

## 后续优化
- **观测性完善**  
  - 接入 `/health`、`/health/ready`，将房间/对战/日志数据暴露给监控系统  
  - 使用 `/api/metrics` 分析前端 BattleEngine 的停顿时间、渲染性能  
  - 在 PvPController 中输出关键事件（房间创建、双方 ready、断线重连）供 LogAggregator 检索  
- **指标面板**  
  - Prometheus：`battle_active_rooms`, `battle_ws_connections`, `battle_pvp_reconnect_errors`  
  - Grafana：实时展示房间状态、对战耗时、错误率  
- **自动恢复**  
  - 部署层使用 `/health/live` 作为 Liveness 探针、`/health/ready` 作为 Readiness，异常时自动重启  

---

## 监控与诊断

| 项目 | 端点/工具 | 说明 |
| ---- | ---- | ---- |
| Prometheus 指标 | `GET /metrics` | 统计 WebSocket 连接、消息、错误、Battle 生命周期 |
| 前端性能 | `POST /api/metrics` | BattleEngine Web Vitals、自定义指标（连接时间、Phase 切换耗时） |
| 健康检查 | `/health`, `/health/live`, `/health/ready` | Node 进程、Pokemon Showdown 依赖、房间/对战统计 |
| 诊断面板 | `GET /api/diagnostics` | 聚合房间队列、Battle 数、日志、CPU/内存占用 |
| 日志查询 | LogAggregator / `logs/*.log` | 按模块定位 PvP 事件、异常 |

> 建议：为 PvP 流程增加自定义指标（如房间配对耗时、重连次数），方便后续分析。

---

### 短期优化（1-2周）

1. **房间列表**
   - 显示所有可用房间
   - 显示房间状态（等待中/对战中）
   - 快速加入功能

2. **匹配系统**
   - 自动匹配玩家
   - 基于等级的匹配
   - 快速匹配功能

3. **对战统计**
   - 胜率统计
   - 对战历史
   - 使用率统计

### 中期优化（1-2月）

1. **观战功能**
   - 允许其他玩家观战
   - 延迟播放（防止作弊）
   - 观战者聊天

2. **对战回放**
   - 保存对战记录
   - 回放系统
   - 分享对战记录

3. **天梯系统**
   - 排位赛
   - 赛季系统
   - 排行榜

### 长期优化（3-6月）

1. **房间类型**
   - 公开房间
   - 私人房间（密码保护）
   - 好友房间

2. **社交功能**
   - 好友系统
   - 聊天系统
   - 邀请功能

3. **锦标赛系统**
   - 创建锦标赛
   - 淘汰赛制
   - 奖励系统

---

## 注意事项

### 安全性

1. **输入验证**
   - 验证所有用户输入
   - 防止注入攻击
   - 限制消息大小

2. **房间安全**
   - 防止房间ID猜测
   - 防止未授权加入
   - 防止DoS攻击

3. **数据验证**
   - 验证队伍数据
   - 验证命令格式
   - 防止作弊

### 性能

1. **连接管理**
   - 限制同时连接数
   - 清理无效连接
   - 优化内存使用

2. **协议优化**
   - 减少不必要的协议
   - 压缩大消息
   - 批量发送协议

3. **房间清理**
   - 定期清理过期房间
   - 及时释放资源
   - 优化查找算法

---

**文档版本**：1.0.0  
**最后更新**：2025-01-16  
**作者**：项目团队

