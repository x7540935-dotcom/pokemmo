# Pokemmo Myself 学习系列 02｜前端架构与对战引擎

> 本篇聚焦前端部分：HTML 入口、`battle-engine` 包结构、状态机与 UI、队伍页面数据加载、性能监控。

---

## 1. HTML 入口与 ES Modules

### 1.1 多入口页面

- `pokemmo.html`：单人 AI 对战入口
- `pvp-lobby.html`：PvP 匹配与房间大厅
- `battle.html`：对战主界面（调试入口）
- `team.html`：队伍搭建与宝可梦信息浏览

这些页面都通过 `<script type="module">` 加载 ES Modules：

```html
<script type="module" src="./packages/battle-engine/src/legacy-shim.js"></script>
```

知识点：

- `<script type="module">` 会以模块方式加载 JS：
  - 自动启用严格模式
  - 支持 `import` / `export`
  - 默认延迟执行（类似 `defer`）
- 浏览器模块解析要求：
  - 必须使用相对/绝对路径（`./`、`../`、`/` 等）
  - 需要显式 `.js` 后缀，例如 `import './PerformanceReporter.js';`

### 1.2 legacy shim 的作用

- 旧代码习惯使用全局变量（如 `window.BattleEngine`）
- `legacy-shim.js` 做的事情：
  - 从 ES Modules 中导入类/函数
  - 统一挂到 `window` 上，兼容老的 `<script>` 使用方式
- 迁移策略：
  - 新代码建议直接 `import { BattleEngine } from './core/BattleEngine.js';`
  - 旧 HTML 若无法大量重写，可继续使用 shim 暴露的全局对象

---

## 2. `packages/battle-engine` 结构

### 2.1 核心目录

```text
packages/battle-engine/src/
├─ core/             # BattleEngine 核心逻辑
├─ state-machine/    # 对战阶段状态机
├─ ui/               # BattleUI 及其渲染逻辑
├─ utils/            # 工具模块（性能监控、Reporter 等）
└─ index.js          # 对外导出入口
```

### 2.2 `BattleEngine` 核心职责

- 管理 WebSocket 连接（由 connection 层提供）
- 发送玩家操作（招式选择、换人、对战请求等）
- 接收 Showdown 协议行：
  - 用 `protocol` 层解析
  - 转换为内部事件或状态变更
- 驱动 `BattleStateMachine` 进行阶段切换：
  - 队伍加载 / 宝可梦数据加载
  - 队伍预览
  - 正式对战
- 通知 UI 层更新界面（队伍列表、场上精灵、招式等）

### 2.3 状态机（`BattleStateMachine`）

知识点：有限状态机（Finite State Machine，FSM）

- 每个阶段（state）都有：
  - `enter()`：进入时执行
  - `handleMessage(msg)`：处理协议或用户事件
  - `exit()`：离开时清理
- `transitionTo(NextState)`：
  - 记录状态切换时间（用于性能监控）
  - 调用当前状态 `exit()`、新状态 `enter()`
- 好处：
  - 将复杂对战流程拆分为若干可理解的小阶段
  - 每个阶段只关心自己处理的协议片段

---

## 3. `BattleUI` 与 DOM 更新

### 3.1 UI 设计原则

- 把 **状态** 与 **渲染** 分离：
  - 状态：由引擎和状态机维护
  - 渲染：`BattleUI` 读取状态并更新 DOM
- UI 类的职责：
  - 负责找到页面上的关键元素（队伍区、战场区、技能按钮等）
  - 提供方法：`updatePokemonDisplay`、`updateMoves`、`updateHPBar` 等

### 3.2 渲染宝可梦信息

以 `updatePokemonDisplay` 为例：

- 接收一个包含当前场上宝可梦信息的对象
- 根据其：
  - 名称 / 等级
  - HP / 状态
  - 头像 / Sprites
- 更新对应 DOM 元素
- 同时记录渲染时间：
  - 在调用前后使用 `performance.now()` 计算耗时
  - 将 `battle_ui_render_time` 上报给性能监控模块

知识点：

- 操作 DOM 的基本方法：`document.querySelector`、`textContent`、`classList` 等
- 性能考虑：
  - 尽量减少 layout / repaint
  - 合理批量更新（本项目规模较小，主要是教学示例）

---

## 4. 队伍搭建页面 `team.html` 的数据加载

### 4.1 问题背景

- 原始做法：在浏览器中直接 `import { BattlePokedex } from './data/pokedex.js';`
- 这会遇到两个问题：
  1. 浏览器无法解析带 `export` 的旧格式脚本
  2. 模块路径 / 文件体积大，直接加载有性能和兼容性问题

### 4.2 新方案：统一的 `fetchShowdownData`

- 做法：
  1. 首选从远程 JSON 源（或预生成的 JSON 文件）加载数据
  2. 如果失败，再退回到本地 `.js` 文件：
     - 使用 `fetch` 读取文本内容
     - 通过简单字符串解析/正则，提取 `export const BattlePokedex = {...}` 的对象部分
     - `JSON.parse` 或 `new Function` 等方式构造 JS 对象（注意安全性，本项目场景是离线本地）
  3. 将解析后的多个数据表挂载到 `window.ShowdownData`：
     - `BattlePokedex`
     - `BattleMovedex`
     - `BattleAbilities`
     - `BattleItems`
     - `BattleLearnsets`

- 然后在 `PokemonTeamBuilder` 中：
  - 调用 `await ensureShowdownData()`
  - 使用 `this.showdownData.BattlePokedex` 等进行渲染

知识点：

- `fetch` API 与 JSON 解析
- 兼容旧格式模块的策略：
  - 不直接 `import`，而是当成普通文本进行解析
- 全局数据缓存：
  - 将较大且不常变的表挂在 `window` 上，减少重复请求

---

## 5. 前端性能监控体系

### 5.1 自定义性能指标（`PerformanceMonitor`）

- 插入点：
  - WebSocket 连接建立：记录 `battle_engine_connect_time`
  - 收到首个协议包：记录 `battle_engine_first_protocol_time`
  - 状态机阶段切换：记录 `battle_phase_transition_time`
  - UI 渲染：记录 `battle_ui_render_time`
- 实现方式：
  - 使用单例 `PerformanceMonitor` 记录事件
  - 方法：
    - `recordMetric(name, value, tags)`
    - 批量缓存到内存中，定期由 `PerformanceReporter` 上报

知识点：

- `performance.now()`：高精度时间
- 自定义埋点设计：定义统一的 metric name / tags 规范

### 5.2 Web Vitals 集成（`WebVitalsReporter`）

- 原始问题：
  - 浏览器无法直接 `import 'web-vitals'`（裸模块名）
  - CDN 加载 `https://unpkg.com/...` 会遇到 CORS / 模块导出不匹配等问题
- 解决方案：
  1. 使用 `npm install web-vitals` 在本地装包
  2. 在 `vendor/web-vitals.js` 中复制其 ESM 版本（带 `export { onCLS, ... }`）
  3. 新建 `web-vitals-shim.js`：
     - 从 vendor 导入 `onCLS` / `onFCP` / `onINP` / `onLCP` / `onTTFB`
     - 暴露 `onFID`，底层复用 `onINP` 以兼容旧接口
  4. `PerformanceMonitor.js` 与 `WebVitalsReporter.js` 中统一从 shim 导入：
     ```js
     import { onCLS, onFID, onFCP, onLCP, onTTFB } from './web-vitals-shim.js';
     ```

知识点：

- 裸模块名与浏览器模块解析限制
- CORS 与 CDN：生产环境可配合构建工具处理，本地开发更推荐本地 vendor 文件
- Web Vitals：
  - `onCLS`：累计布局偏移
  - `onLCP`：最大内容绘制
  - `onFID` / `onINP`：首次输入延迟 / 交互响应性
  - `onTTFB`：首字节时间

### 5.3 数据上报（`PerformanceReporter`）

- 职责：
  - 从 `PerformanceMonitor` 获取已记录的 metrics
  - 以批量形式通过 `fetch('/api/metrics')` POST 给后端
  - 加入重试和本地缓存（localStorage）：
    - 上报失败时先持久化
    - 下次成功时顺便带上旧数据

知识点：

- 前端与后端 API 约定：
  - JSON 结构（如 `{ name, value, tags, timestamp }` 列表）
  - 错误处理策略（失败重试 / 丢弃策略）
- `localStorage` 用于小规模持久化缓存

---

## 6. 调试前端的常用技巧

1. **Network 面板**
   - WebSocket 子面板：查看 `ws://.../battle` 的收发消息
   - XHR/Fetch：确认 `/api/metrics` 上报是否成功
2. **Sources 面板**
   - 直接在 ES Module 源文件上打断点（如 `BattleEngine.js`、`BattleStateMachine.js`）
3. **Console**
   - 观察 `console.log` / `Logger` 输出
   - 注意捕获 `Uncaught SyntaxError` / `TypeError` 等报错
4. **Performance / Lighthouse**
   - 与 Web Vitals 指标对照，验证优化是否生效

> 建议阅读顺序：  
> - 若你主要关心「如何改前端逻辑」，配合查看 `docs/modules/前端模块说明.md`  
> - 若你要理解完整对战流程，下一篇建议阅读《学习系列 03｜后端架构与 WebSocket 实战》  


