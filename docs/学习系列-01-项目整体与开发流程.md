# Pokemmo Myself 学习系列 01｜项目整体与开发流程

> 本系列文档面向：想系统学习本项目架构与工程实践的人  
> 本篇聚焦「整体视角」与「日常开发流程」，后续篇章会分别讲前端、后端、资源流水线、可观测性等。

---

## 1. 项目定位与整体结构

### 1.1 项目是什么

- **本质**：基于 Pokemon Showdown 协议的本地化宝可梦对战平台
- **能力**：
  - AI 对战（本地随机队伍 + AI 决策）
  - 真人 PvP（双人联机对战）
  - 队伍管理 / 中文数据 / 本地资源缓存
  - 对战过程日志、性能指标、健康检查、Prometheus 指标

### 1.2 顶层目录结构

（只列与本项目直接相关的部分）

```text
pokemmo/
└─ pokemmo myself/
   ├─ data/                 # Showdown / 中文数据 / manifest
   ├─ packages/
   │  └─ battle-engine/     # 前端对战引擎（WebSocket + 协议 + 状态机 + UI）
   ├─ poke-proxy-server/    # Node.js 后端（WS 代理 + AI + PvP + 指标）
   ├─ tools/                # 资源 manifest、体积检查、校验等脚本
   ├─ docs/                 # 所有文档（重构路线、开发指南、学习系列）
   ├─ *.html                # 前端入口：pokemmo.html / pvp-lobby.html / team.html / battle.html
   └─ simple-http-server.js # 简易静态服务器（分享/多端访问）
```

### 1.3 核心子项目

- **前端引擎 `packages/battle-engine`**
  - 按层次拆分：
    - `connection`：WebSocket 连接、心跳、重连、诊断
    - `protocol`：解析与路由 Showdown 协议
    - `state-machine`：对战阶段状态机（队伍加载、预览、对战等）
    - `ui`：`BattleUI` 及其子组件，负责 DOM 渲染
    - `utils`：性能监控、WebVitals、工具函数
  - 技术点：ES Modules、class 设计、事件驱动、性能监控（自定义 + Web Vitals）

- **后端 `poke-proxy-server`**
  - 层次：
    - `server/bootstrap.js`：HTTP + WebSocket 引导、端点注册
    - `controllers/`：连接控制、AI 对战控制、PvP 房间控制
    - `domain/`：`RoomManager`、`BattleManager` 等领域对象
    - `adapters/`：Showdown 适配、日志系统、Prometheus 指标
    - `server/*.js`：metrics / health / metrics API 等 HTTP 端点
  - 技术点：Node.js、`ws` WebSocket、分层架构、依赖注入式设计

---

## 2. 开发工具与运行环境

### 2.1 环境要求

- **Node.js 18+**：运行后端 battle server、资源脚本、简单 HTTP 服务器
- **npm**：安装依赖、执行 npm scripts
- **现代浏览器**：支持 WebSocket、ES Modules（`<script type="module">`）
- **可选 Python 3.8+**：部分 RAG / 数据脚本（当前可以只关注 Node 侧）

### 2.2 使用到的主要工具

- **Node.js / npm**
  - 安装依赖：`npm install`
  - 脚本执行：`npm run xxx`
- **VS Code / WebStorm / PyCharm 等 IDE**
  - 前端调试（Network / Console / Sources）
  - Node 调试（Run/Debug Config）
- **Jest**
  - 单元测试 / 集成测试（RoomManager、BattleManager、WS 冒烟）
- **Playwright**
  - 端到端（E2E）测试，对页面行为进行自动化验证
- **ESLint**
  - 静态检查，保证 JS 代码风格与潜在错误
- **Prometheus + `prom-client`**
  - 后端 WebSocket 连接 / 消息 / 错误 / battle 时长 等指标
- **Chrome DevTools**
  - Network：检查 WebSocket 连接、静态资源加载
  - Performance：配合前端自定义指标、Web Vitals 做性能分析

---

## 3. 本地开发流程（从零到可对战）

### 3.1 一次性初始化

在 `pokemmo myself` 目录：

```bash
cd "E:\XIANGMU\pokemmo\pokemmo myself"
npm install

cd "poke-proxy-server"
npm install
```

> 依赖说明  
> - 根目录：简单 HTTP 服务器脚本、工具脚本等  
> - `poke-proxy-server`：后端运行依赖（`ws`、`prom-client` 等）

### 3.2 启动后端 battle server

```bash
cd "pokemmo myself/poke-proxy-server"
node battle-server.js
```

涉及知识点：

- Node.js CommonJS 模块（`require` / `module.exports`）
- WebSocket 服务器（`ws` 包）
- 引导流程：
  - 创建 HTTP server
  - 挂载 WebSocketServer
  - 注册 `/metrics`、`/health`、`/api/metrics` 等端点
  - 初始化 `RoomManager`、`BattleManager`、AI 预热

### 3.3 启动前端 HTTP 服务器（推荐）

```bash
cd "pokemmo myself"
node simple-http-server.js 8080
```

访问示例：

- AI 对战入口：`http://localhost:8080/pokemmo.html`
- PvP 房间大厅：`http://localhost:8080/pvp-lobby.html`
- 对战页面（调试用）：`http://localhost:8080/battle.html`
- 队伍搭建页面：`http://localhost:8080/team.html`

涉及知识点：

- 简单静态服务器原理：读取本地文件、按路径映射返回 HTML/JS/CSS
- 浏览器直接加载 ES Module：`<script type="module" src="...">`

---

## 4. 前端核心知识点一览

### 4.1 ES Modules 与浏览器模块加载

- 使用方式：
  - 在 HTML 中：`<script type="module" src="packages/battle-engine/src/legacy-shim.js"></script>`
  - 在 JS 中：
    ```js
    import { BattleEngine } from './core/BattleEngine.js';
    ```
- 注意事项：
  - **必须带 `.js` 后缀**（浏览器不会自动补）
  - 不能使用裸模块名（如 `import 'web-vitals'`），需要：
    - 相对路径（`./`、`../`）
    - 或在项目内提供一个 vendor 文件（例如本项目的 `vendor/web-vitals.js`）

### 4.2 WebSocket 客户端

- 连接：
  ```js
  const ws = new WebSocket('ws://localhost:3071/battle');
  ws.onopen = () => { /* ... */ };
  ws.onmessage = (event) => { /* 协议解析 */ };
  ws.onclose = () => { /* 清理 */ };
  ```
- 在本项目中，连接管理被封装到 `connection` 层，并通过 `BattleEngine` 暴露给 UI：
  - 自动处理连接、心跳、重连
  - 记录 `battle_engine_connect_time` 等性能指标

### 4.3 性能监控与 Web Vitals

- `PerformanceMonitor`：
  - 自定义指标：连接时间、首包时间、UI 渲染时间、状态切换时间等
  - 使用 `performance.now()`、自定义事件等原生 API
- `WebVitalsReporter`：
  - 从 `vendor/web-vitals.js` 导入 `onCLS` / `onLCP` / `onTTFB` 等
  - 通过 `PerformanceReporter` 批量发送到后端 `/api/metrics`
- 知识点：
  - 浏览器性能 API（`PerformanceObserver`、`performance.getEntriesByType`）
  - Web Vitals 指标含义（LCP、FID/INP、CLS、FCP、TTFB）

---

## 5. 后端核心知识点一览

### 5.1 WebSocket 服务器（`ws`）

- 创建 HTTP + WS：
  ```js
  const httpServer = http.createServer();
  const wss = new WebSocketServer({ server: httpServer, path: '/battle' });

  wss.on('connection', (ws, req) => {
    // 交给 connectionController 处理
  });
  ```
- 在本项目中：
  - 使用 `connectionController.handleConnection` 作为入口
  - 包裹 `wrapWebSocket` 以采集 Prometheus 指标

### 5.2 分层架构与领域对象

- 控制器层（controllers）：
  - 负责 HTTP/WS 请求与领域对象之间的协调
- 领域层（domain）：
  - `RoomManager`：房间管理、匹配、统计
  - `BattleManager` / `SimplePvPManager`：对战生命周期管理
- 适配层（adapters）：
  - Showdown BattleStream 适配
  - 日志适配（JSONFormatter、TextFormatter、LogFileWriter、LogAggregator）
  - 指标适配（PrometheusMetrics、WebSocketMetrics）

### 5.3 日志与可观测性

- 统一 Logger：
  - 支持 `info` / `warn` / `error` / `fatal`
  - 支持 JSON 格式输出 + 文件写入
  - 通过 `LogAggregator` 在内存中聚合，便于调试与健康端点查询
- 健康检查端点：
  - `/health` / `/health/live` / `/health/ready`：基本健康状态
  - `/api/diagnostics`：详细信息（连接数、房间数、对战数、日志统计、性能指标摘要）
- Prometheus 指标：
  - `ws_connections_total`、`ws_messages_total`、`ws_errors_total`
  - Battle 时长直方图、进程内存、uptime 等

---

## 6. 日常开发与调试建议

1. **改前端逻辑**：
   - 只改 `packages/battle-engine/src` 下对应模块
   - 使用 Chrome DevTools 观察 WebSocket 消息流与性能
2. **改后端逻辑**：
   - 在 `poke-proxy-server` 下定位对应控制器 / 领域类
   - 利用统一 Logger 打印结构化日志
3. **运行测试与校验**：
   - 单元/集成测试：`npm test`（根据项目脚本）
   - 前端 E2E：`npm run e2e`（Playwright）
   - Lint：`npm run lint`
   - 资源检查：`npm run build:manifest` / `npm run check:assets` / 体积阈值脚本
4. **观察运行状态**：
   - 打开 `/metrics` 看 Prometheus 指标（开发时可直接用浏览器访问）
   - 打开 `/api/metrics` 或 `/api/diagnostics` 查看性能与状态摘要

> 后续篇章  
> - 02：前端模块化与队伍/对战 UI 实战  
> - 03：后端 WebSocket + 房间/对战模型详解  
> - 04：资源流水线、CI/CD 与测试体系  
> - 05：可观测性与线上运维实践  


