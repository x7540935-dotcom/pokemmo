# Pokemmo Myself 架构说明文档（重构版）

> 更新时间：2025-11-18  
> 本文覆盖「现状」与「目标」两套架构视图，并给出迁移策略。

---

## 1. 总览

### 1.1 系统图（目标状态）
```
┌───────────────────────────────────────────────┐
│                   前端层                      │
│ ┌────────────┐  ┌────────────┐  ┌──────────┐ │
│ │ apps/pokemmo│ │apps/pvp-lobby│ │apps/battle│ │
│ └──────▲─────┘  └──────▲─────┘  └──────▲───┘ │
│        │               │               │      │
│ ┌──────┴───────────────────────────────┴───┐ │
│ │ packages/battle-engine                   │ │
│ │ ├─ connection (WebSocket)                │ │
│ │ ├─ protocol (parser/router)              │ │
│ │ ├─ state (state machine + phases)        │ │
│ │ └─ ui (BattleUI + skin)                  │ │
│ └──────────────────────────────────────────┘ │
└───────────────────────────┬──────────────────┘
                            │ WebSocket
┌───────────────────────────▼──────────────────┐
│                   后端层                      │
│ ┌──────────────────────────────────────────┐ │
│ │ services/battle-server                   │ │
│ │ ├─ bootstrap (HTTP/WS)                   │ │
│ │ ├─ controllers                           │ │
│ │ │   ├─ PvPController                     │ │
│ │ │   └─ AIBattleController                │ │
│ │ ├─ domain                                │ │
│ │ │   ├─ BattleManager / SimplePvPManager  │ │
│ │ │   ├─ RoomManager                       │ │
│ │ │   └─ ChoiceHandlers                    │ │
│ │ └─ adapters                              │ │
│ │     ├─ Pokemon Showdown BattleStream     │ │
│ │     ├─ LLM / RAG                         │ │
│ │     └─ Resource services                 │ │
│ └──────────────────────────────────────────┘ │
└──────────────────────────────────────────────┘
```

### 1.2 关键理念
- **分层**：接口层（HTML/HTTP）、应用层（控制器/阶段）、领域层（对战/房间）、基础设施（Showdown、资源）
- **解耦**：前端入口间共享 `battle-engine` 包；后端拆出控制器与领域对象
- **协议驱动**：Pokemon Showdown 协议流 + JSON 控制消息
- **可观测性**：统一日志格式、协议追踪、AI 决策记录

---

## 2. 前端架构

### 2.1 现状
- 多个 HTML（`pokemmo.html`, `pvp-lobby.html`, `battle.html`, `team.html`）已通过 `<script type="module">` 引入 `packages/battle-engine/src/legacy-shim.js`，由 shim 负责暴露全局类
- `BattleEngine` / `Phase` / `UI` 等已经转换为 ES Modules，可通过 `import` 在新页面中直接消费
- 仍缺少正式的打包产物（目前由浏览器直接加载 `src/`），后续 Phase 2.1 需要补齐 bundler 与版本输出
- legacy shim 兼容模式仍存在，待新 UI/路由完成后可逐步移除

### 2.2 目标布局
| 层级 | 目录 | 职责 |
| ---- | ---- | ---- |
| 入口 | `apps/*` | UI & 路由，消费 battle-engine |
| 引擎 | `packages/battle-engine` | 连接、协议、状态机、UI 基础组件 |
| 资源 | `packages/localization` | 翻译、Sprites manifest |
| 工具 | `packages/shared` | Logger、类型定义 |

### 2.3 模块拆分（battle-engine）
1. **connection**：封装 WebSocket、心跳、重连、诊断；输出事件流
2. **protocol**：解析 Pokemon Showdown 协议，支持插件式 handler
3. **state**：状态机 + Phase（TeamLoading/TeamPreview/PokemonData/Battle）
4. **ui**：可注入的 UI 渲染器，支持不同壳（经典 HTML / 未来框架）
5. **diagnostics**：协议日志、性能统计、mock 工具

### 2.4 数据流（前端）
```
用户操作 → UI 层 → StateMachine → BattleEngine.send()
BattleEngine.onmessage → ProtocolParser → Phase.handleProtocol → StateManager → UI
```

---

## 3. 后端架构

### 3.1 现状问题
- `battle-server.js` >1500 行，负责：HTTP/WS、AI 队伍生成、资源检测、PvP 房间、AI 决策
- 配置散落在文件顶部常量，无法通过环境变量/配置文件统一管理
- 日志与错误处理没有统一格式

### 3.2 目标分层
| 层 | 目录 | 说明 |
| -- | ---- | ---- |
| Bootstrap | `services/battle-server/server` | HTTP/WS 启动、CORS、健康检查 |
| Controllers | `services/battle-server/controllers` | PvP / AI / Diagnostics 控制器 |
| Domain | `services/battle-server/domain` | BattleManager、RoomManager、ChoiceHandlers |
| Infrastructure | `services/battle-server/adapters` | Pokemon Showdown、RAG、资源加载 |
| Shared | `services/battle-server/shared` | Logger、Config、Errors、Events |

### 3.3 核心组件（Domain）
1. **BattleManager**：封装 BattleStream 生命周期，处理 AI vs Player
2. **SimplePvPManager**：管理多路 BattleStream、缓存协议用于重连
3. **RoomManager / Room**：负责房间状态、超时、清理
4. **ChoiceHandlers**：`PlayerChoiceHandler`、`AIChoiceHandler`（Simple/Medium/Advanced/Expert）
5. **ProtocolRouter**：将 BattleStream 输出分发给监听者，并写入日志/缓存

### 3.4 数据流（AI 对战）
```
客户端 start → AIBattleController → BattleManager.create()
BattleStream 输出 → ProtocolRouter → WebSocket 客户端
request 协议 → PlayerChoiceHandler / AIChoiceHandler → BattleStream
```

### 3.5 数据流（PvP）
```
pvp-lobby.html → PvPController（创建/加入房间） → RoomManager
双方 ready → SimplePvPManager 接管 BattleStream
协议缓存 → 断线重连时通过 battle-reconnected JSON 发送
```

### 3.6 配置策略
- `.env`（端口、资源目录、AI 选项、RAG Key）
- `config/schema.ts` 使用 Zod/Joi 校验
- `ConfigService` 负责读取并提供默认值，避免 `process.env` 散落

---

## 4. 数据与资源

| 资源 | 位置 | 说明 | 重构动作 |
| ---- | ---- | ---- | ---- |
| 中文数据 | `data/chinese/*.json` | 名称/技能/道具/特性 | 生成 manifest + 校验脚本 |
| Sprites | `cache/sprites/*` | 由 proxy 或脚本下载 | 构建 `sprites-manifest.json`，缺失写入 `missing-sprites.json` |
| RAG | `RAG/` | 知识库 + 模型脚本 | 纳入可选模块，提供接口层 |
| 日志 | 待定 | WebSocket/AI/房间日志 | 统一 `logs/*.log`，支持 JSONL |

---

## 5. 关键设计模式

| 模式 | 应用位置 | 作用 |
| ---- | ---- | ---- |
| 状态机 | 前端 battle phases | 控制对战流程、避免条件爆炸 |
| 观察者 | WebSocket 事件、ProtocolRouter、性能监控钩子 | 解耦发送方/监听方 |
| 策略 | AIChoiceHandler | 不同难度 AI 的行为切换 |
| 工厂 | BattleManager/PvPManager 创建流 | 按模式创建 BattleStream |
| 缓存 | SimplePvPManager、LogAggregator | 重连时复用协议/日志 |

---

## 6. 通信协议

### 6.1 Pokemon Showdown 协议（节选）
- `|player|p1|...`：房间初始化
- `|poke|p1|Garchomp,...`：队伍信息
- `|request|{...}`：请求玩家/AI 做出选择
- `|switch|p1a: Garchomp|...`：场上替换
- `|win|玩家名`：胜利判定

### 6.2 自定义 JSON 控制消息
| 类型 | 方向 | 用途 |
| ---- | ---- | ---- |
| `room-created` | Server → Client | 返回房间号 |
| `room-joined` | Server → Client | 双方均已入房间 |
| `battle-reconnected` | Server → Client | 断线恢复 |
| `diagnostics` | Server → Client | 调试信息（WS 状态、AI 失败等） |

---

## 7. 观测性与运维

### 7.1 日志与聚合
- 统一使用 `adapters/logging/Logger`，支持 `debug/info/warn/error/fatal`
- 可配置输出：控制台、JSON 文件、Log Aggregator（内存）
- `LogAggregator` 暴露 `getStats()`，供 /api/diagnostics、/health consumed

### 7.2 指标
- Prometheus 端点：`GET /metrics`
- WebSocket 指标：连接数 / 消息量 / 错误数 / 延迟直方图
- 前端性能：Web Vitals + 自定义埋点（BattleEngine、StateMachine、UI）
- 性能数据上报：`packages/battle-engine/src/utils/PerformanceReporter.js` → `POST /api/metrics`

### 7.3 健康检查
- `GET /health`：综合状态（含服务/资源/日志/指标）
- `GET /health/live`：进程存活探针
- `GET /health/ready`：依赖就绪探针（Pokemon Showdown 适配器、WS 监听、Room/Battle stats）
- `GET /api/diagnostics`：详细诊断（连接、房间、Battle、日志、内存、CPU）

### 7.4 事件与报警
- 可在 Prometheus / Grafana 中订阅指标告警
- RoomManager 提供 `getStats()`，便于推送房间队列状态
- BattleManager 暴露协议日志，支持重放与追踪

---

## 8. 扩展性计划

1. **多终端**：BattleEngine 输出可同时服务 Web / Desktop（Electron）
2. **自定义规则**：引入格式插件（自定义 Banlist / 道具限制）
3. **AI 增强**：允许注入第三方推理服务，BattleManager 只需遵守接口
4. **观测性**：整合 Prometheus 指标（房间数、AI 延迟、WS 链接数）
5. **发布流水线**：构建 → 体积审计 → e2e → 上传资源 manifest

---

## 9. 迁移策略

| 步骤 | 说明 |
| ---- | ---- |
| 1 | 在不影响旧页面的情况下，将 BattleEngine 拆成多个模块文件 |
| 2 | 引入构建工具，生成旧入口可用的 IIFE bundle |
| 3 | 后端增加 `ConfigService` 与 `Logger`，逐步从 `battle-server.js` 中抽离 |
| 4 | 将 Room / AI 逻辑迁移到新目录，并编写单元测试 |
| 5 | 添加资源 manifest 生成脚本与健康/指标端点，更新文档 |

---

## 10. 参考
- `docs/项目开发文档.md`
- `docs/modules/前端模块说明.md`
- `docs/modules/后端模块说明.md`
- `docs/architecture/重构路线图.md`

> 如需新增架构决策，请创建 `docs/architecture/adr/ADR-xxxx.md` 并在路线图登记。

### 3.5 房间管理

#### 3.5.1 RoomManager (房间管理器)

**职责**：
- 创建、查找、删除房间
- 定期清理过期房间
- 验证队伍数据

**房间生命周期**：
1. 创建房间（generateRoomId）
2. 玩家加入（joinRoom）
3. 开始对战（状态变为battling）
4. 对战结束或超时（deleteRoom）

#### 3.5.2 Room (房间类)

**职责**：
- 管理房间状态
- 跟踪玩家连接和队伍
- 提供广播消息功能

**房间状态**：
- `waiting`: 等待玩家加入
- `ready`: 双方已准备好
- `battling`: 对战进行中
- `ended`: 对战已结束

### 3.6 AI系统架构

#### 3.6.1 AI系统层次

```
┌─────────────────────────────────────────┐
│      AIChoiceHandler (选择处理器)        │
│  - 难度路由                               │
│  - 选择生成和发送                          │
└──────────────────┬──────────────────────┘
                   │
┌──────────────────▼──────────────────────┐
│         AI策略层 (Strategy Layer)        │
│  ┌──────────┐  ┌──────────┐            │
│  │SimpleAI  │  │MediumAI  │  ...       │
│  └──────────┘  └──────────┘            │
└──────────────────┬──────────────────────┘
                   │
┌──────────────────▼──────────────────────┐
│        工具层 (Tools Layer)              │
│  TypeChartCalculator, DamageCalculator,  │
│  BattleStateAnalyzer, StrategyEvaluator  │
└──────────────────┬──────────────────────┘
                   │
┌──────────────────▼──────────────────────┐
│      RAG/LLM层 (可选)                    │
│  RAGIntegration, LLMClient,              │
│  PromptBuilder                           │
└─────────────────────────────────────────┘
```

#### 3.6.2 AI策略类

**SimpleAI (难度1-2)**：
- 难度1: 完全随机选择
- 难度2: 基于属性克制的简单策略

**MediumAI (难度3)**：
- 考虑属性克制、HP状态、技能威力
- 综合评分：属性克制50% + 威力30% + 命中率20%

**AdvancedAI (难度4)**：
- 使用所有辅助工具进行深度分析
- 评估所有可能的行动选项
- 使用StrategyEvaluator进行综合评估

**ExpertAI (难度5)**：
- 集成RAG系统和LLM
- 使用PromptBuilder构建提示词
- 结合工具计算结果和LLM建议
- 提供降级方案（如果LLM不可用）

#### 3.6.3 AI工具类

**TypeChartCalculator (属性克制计算器)**：
- 18种属性的完整克制表
- 计算技能对宝可梦的伤害倍数
- 支持双属性宝可梦的克制计算

**DamageCalculator (伤害计算器)**：
- 使用Pokemon Showdown公式计算伤害
- 预测伤害范围（最小、最大、平均）
- 计算伤害百分比和击杀概率

**BattleStateAnalyzer (状态分析器)**：
- 解析HP百分比、状态异常、能力等级
- 评估宝可梦健康状态
- 判断是否需要换人

**StrategyEvaluator (策略评估器)**：
- 评估技能和换人选项的综合评分
- 考虑伤害、克制、风险、功能性
- 排序选项并选择最佳行动

---

## 4. 数据流和通信协议

### 4.1 通信协议

#### 4.1.1 WebSocket消息格式

**客户端 → 服务器**：
```json
{
  "type": "start" | "choose" | "join-room" | "create-room",
  "payload": { ... }
}
```

**服务器 → 客户端**：
- Pokemon Showdown协议格式：`|protocol|param1|param2|...`
- JSON控制消息：`{"type": "battle-reconnected", "payload": {...}}`

#### 4.1.2 关键协议类型

**request协议**：
```
|request|{"active": [...], "side": {...}, "rqid": 1}
```
- 请求玩家做出选择（技能或换人）
- 包含当前场上宝可梦信息和可用选项

**switch协议**：
```
|switch|p1a: Pokemon|details|HP/status
```
- 宝可梦切换或状态更新

**poke协议**：
```
|poke|p1|Pokemon|details|item
```
- 队伍预览信息

**damage/heal协议**：
```
|damage|p1a: Pokemon|100/100 → 50/100
|heal|p1a: Pokemon|50/100 → 75/100
```
- 伤害和回复信息

### 4.2 AI对战数据流

```
1. 前端发送start消息
   ↓
2. battle-server.js接收，创建BattleManager
   ↓
3. BattleManager初始化BattleStream，发送队伍
   ↓
4. BattleStream生成协议（poke, teampreview, request等）
   ↓
5. ProtocolRouter路由协议
   ↓
6. PlayerChoiceHandler处理玩家选择
   AIChoiceHandler处理AI选择
   ↓
7. 选择发送回BattleStream
   ↓
8. BattleStream计算对战结果，生成新协议
   ↓
9. 协议转发回前端
   ↓
10. 前端解析协议，更新UI
```

### 4.3 PvP对战数据流

```
1. 玩家1创建房间
   ↓
2. 玩家2加入房间
   ↓
3. 双方提交队伍
   ↓
4. PvPHandler创建SimplePvPManager
   ↓
5. SimplePvPManager初始化BattleStream
   ↓
6. BattleStream生成协议
   ↓
7. SimplePvPManager缓存协议并转发
   ↓
8. 双方客户端接收协议，做出选择
   ↓
9. 选择发送回SimplePvPManager
   ↓
10. SimplePvPManager转发到BattleStream
   ↓
11. BattleStream计算，生成新协议
   ↓
12. 循环步骤7-11直到对战结束
```

### 4.4 重连机制

**PvP重连流程**：
1. 客户端检测到连接断开
2. 自动重连WebSocket
3. 发送重连消息（包含房间ID和side）
4. 服务器查找房间和连接
5. 发送battle-reconnected确认消息
6. 重新发送所有缓存的协议（omniscient + 玩家特定）

**协议缓存策略**：
- 所有协议按类型分类缓存
- 重连时按顺序重新发送
- 确保客户端状态同步

---

## 5. 模块间关系

### 5.1 前端模块依赖关系

```
BattleUI
  ↓
BattleStateMachine
  ↓
PhaseBase ← TeamLoadingPhase, TeamPreviewPhase, BattlePhase, ...
  ↓
BattleEngine → ProtocolParser → StateManager
  ↓
Utils (Logger, Localization, PokemonUtils, SpriteLoader, MoveDataHelper)
```

### 5.2 后端模块依赖关系

```
battle-server.js
  ↓
PvPHandler → RoomManager → Room
  ↓         ↓
  │         SimplePvPManager → BattleStream
  │
  AIHandler → BattleManager → BattleStream
              ↓
         ProtocolRouter
              ↓
    PlayerChoiceHandler / AIChoiceHandler
              ↓
         AI策略类 (SimpleAI, MediumAI, ...)
              ↓
         工具类 (TypeChartCalculator, ...)
```

### 5.3 模块通信方式

**前端**：
- 事件驱动：Phase通过事件通知StateMachine
- 回调函数：BattleEngine通过回调通知Phase
- 直接调用：UI直接调用Phase方法

**后端**：
- 直接调用：Handler直接调用Manager方法
- 事件监听：Manager监听BattleStream事件
- 协议路由：ProtocolRouter路由协议到Handler

---

## 6. 关键设计模式

### 6.1 状态机模式 (State Machine Pattern)

**应用位置**：前端BattleStateMachine

**实现**：
- 每个Phase是一个状态
- StateMachine管理状态转换
- Phase通过transitionTo方法请求转换

**优势**：
- 清晰的状态管理
- 易于添加新阶段
- 状态转换逻辑集中

### 6.2 观察者模式 (Observer Pattern)

**应用位置**：
- BattleEngine的事件监听
- Phase的协议处理器注册

**实现**：
- 事件监听器注册
- 事件触发时通知所有监听器

**优势**：
- 解耦事件发送者和接收者
- 支持多个监听器
- 动态添加/移除监听器

### 6.3 策略模式 (Strategy Pattern)

**应用位置**：AI系统

**实现**：
- 不同难度的AI实现不同的策略接口
- AIChoiceHandler根据难度选择策略

**优势**：
- 易于添加新的AI策略
- 策略之间相互独立
- 运行时选择策略

### 6.4 工厂模式 (Factory Pattern)

**应用位置**：
- AIChoiceHandler创建AI实例
- RoomManager创建Room实例

**实现**：
- 根据参数创建不同类型的对象
- 封装对象创建逻辑

**优势**：
- 统一对象创建接口
- 隐藏创建细节
- 易于扩展

### 6.5 单例模式 (Singleton Pattern)

**应用位置**：
- Logger实例（每个模块一个）
- Localization实例（全局单例）

**实现**：
- 确保只有一个实例
- 提供全局访问点

**优势**：
- 节省资源
- 全局状态管理
- 避免重复初始化

---

## 7. 技术栈详解

### 7.1 前端技术栈

**核心语言**：
- JavaScript (ES6+)
  - 类、箭头函数、解构赋值、async/await
  - 模块化（ES6 Modules）

**通信技术**：
- WebSocket API
  - 原生WebSocket，无需第三方库
  - 支持二进制和文本消息

**UI技术**：
- HTML5
  - 语义化标签
  - 本地存储（localStorage）
- CSS3
  - Flexbox布局
  - 动画效果

**数据存储**：
- localStorage
  - 队伍数据持久化
  - 用户偏好设置

### 7.2 后端技术栈

**运行环境**：
- Node.js
  - 事件驱动、非阻塞I/O
  - 丰富的内置模块

**WebSocket库**：
- ws
  - 高性能WebSocket服务器
  - 支持HTTP升级

**对战引擎**：
- Pokemon Showdown
  - 完整的对战逻辑
  - 协议标准
  - BattleStream接口

**AI技术**：
- 规则基础AI（难度1-2）
- 策略AI（难度3-4）
- RAG + LLM（难度5，可选）
  - 阿里云百炼平台
  - Python RAG系统

### 7.3 开发工具

**版本控制**：
- Git

**包管理**：
- npm

**代码规范**：
- JSDoc注释
- 模块化设计
- 单一职责原则

---

## 8. 系统扩展性

### 8.1 前端扩展

**添加新阶段**：
1. 继承PhaseBase
2. 实现onEnter、onExit、handleProtocol等方法
3. 在BattleStateMachine中注册

**添加新协议处理**：
1. 在ProtocolParser中注册协议类型
2. 在对应Phase中实现处理逻辑

**添加新UI组件**：
1. 在BattleUI中添加渲染方法
2. 在对应Phase中调用

### 8.2 后端扩展

**添加新AI难度**：
1. 创建新的AI类（继承或实现相同接口）
2. 在AIChoiceHandler中注册
3. 实现generateChoice方法

**添加新工具**：
1. 在tools目录下创建新工具类
2. 在index.js中导出
3. 在AI类中使用

**添加新协议处理**：
1. 在ProtocolRouter中添加协议识别
2. 实现对应的处理方法
3. 路由到相应的Handler

### 8.3 性能优化

**前端优化**：
- 协议解析缓存
- UI更新批处理
- 图片懒加载

**后端优化**：
- 协议缓存机制
- 连接池管理
- AI计算优化

**扩展性考虑**：
- 支持多房间并发
- 支持多AI实例
- 支持协议压缩

---

## 9. 安全考虑

### 9.1 前端安全

- 输入验证（队伍数据、选择命令）
- XSS防护（数据转义）
- 路径遍历防护（文件访问）

### 9.2 后端安全

- WebSocket连接验证
- 消息格式验证
- 房间访问控制
- 资源限制（防止DoS）

---

## 10. 总结

Pokemmo Myself 采用**前后端分离**、**模块化设计**、**协议驱动**的架构，具有以下特点：

1. **清晰的层次结构**：前后端都有明确的分层
2. **模块化设计**：每个模块职责单一，易于维护
3. **状态机管理**：前端使用状态机管理复杂流程
4. **协议驱动**：基于Pokemon Showdown标准协议
5. **可扩展性**：易于添加新功能和AI策略
6. **实时通信**：WebSocket实现低延迟对战体验

该架构支持AI对战和PvP对战两种模式，具有良好的扩展性和维护性。

---

**文档版本**：1.0.0  
**最后更新**：2025-01-16  
**维护者**：项目开发团队

