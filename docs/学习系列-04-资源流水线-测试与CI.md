# Pokemmo Myself 学习系列 04｜资源流水线、测试与 CI

> 本篇聚焦「工程化」：资源管理、脚本与 manifest、体积检查、单元测试/集成测试、E2E 测试，以及 CI 配置思路。  
> 目标是让读者了解：如何让一个“能跑”的项目变成“可维护、可持续演进”的工程。

---

## 1. 资源管理与 Manifest 系统

### 1.1 为什么需要 Manifest

项目中存在大量静态资源：

- Sprites（宝可梦立绘、对战精灵图等）
- 中文化数据文件
- Showdown 数据（pokedex / moves / items / abilities / learnsets）

如果不做统一管理，会出现：

- 某些资源路径写死在代码里，重构时容易遗漏
- 删除/移动资源后，引用处不会自动报错
- 难以统计整体体积，无法做优化决策

**Manifest 的作用**：

- 用脚本扫描资源目录，生成统一的 JSON 清单：
  - key：逻辑名称（如 `sprites/front/pikachu.png`）
  - value：真实路径、尺寸信息、哈希值等
- 运行时只依赖 Manifest，而不是硬编码路径。

### 1.2 资源 Manifest 生成脚本

在 `tools/`（或类似目录）中实现脚本：

- 功能：
  - 递归遍历资源目录
  - 按文件名/路径规则生成 key
  - 计算体积、可选生成 hash
  - 输出到 `data/manifests/*.json`
- 知识点：
  - Node.js 文件系统 API（`fs` / `path`）
  - 同步 vs 异步 IO 的取舍（构建脚本一般用同步简化逻辑）
  - JSON 读写与相对路径处理

在 `package.json` 中配置脚本（示例）：

```json
{
  "scripts": {
    "build:manifest": "node tools/build-manifests.js"
  }
}
```

### 1.3 资源校验脚本

除了生成，也要**校验**：

- 检查 Manifest 中的每一项路径是否在文件系统中存在
- 检查引用的 key 是否都出现在 Manifest 中：
  - 如 JS/HTML 中使用的 `spriteKey` 集合
- 体积阈值校验：
  - 统计 Sprites 总体积
  - 若超出阈值（如 200MB），给出警告或错误

知识点：

- 静态分析思路：不运行应用，仅用脚本分析文件/引用关系
- 在 CI 中阻断过大的资源合入（防止“无意识膨胀”）

---

## 2. 测试体系：单元、集成、E2E

### 2.1 Jest 单元/集成测试

项目使用 Jest 对后端核心逻辑做测试：

- 测试对象举例：
  - `RoomManager`：
    - 创建房间、加入房间、清理、统计
    - 边界条件：重复加入、房间满员、超时清理
  - `BattleManager`：
    - 对战生命周期：创建、开始、结束
    - 与 Showdown BattleStream 的交互（可 mock）
  - 简单 WebSocket 冒烟测试：
    - 使用 `ws` 客户端连接本地 server
    - 发送基本指令，确认服务器响应

知识点：

- Jest 配置：
  - `jest.config.js` / `package.json` 中的 `jest` 字段
  - 使用 `testEnvironment: 'node'`
- Mock 技巧：
  - 用 `jest.fn()` 模拟某些依赖（如 BattleStream）
  - 控制测试中的时间和随机性

命令示例：

```bash
cd "pokemmo myself/poke-proxy-server"
npm test
```

### 2.2 Playwright E2E 测试

Playwright 用于对前端页面进行端到端验证：

- 用例示例：
  - 打开 `pokemmo.html`，启动 AI 对战：
    - 输入必要参数/配置
    - 检查对战界面是否正常加载
    - 检查若干 UI 元素（如宝可梦名称、技能按钮）
  - 打开 `pvp-lobby.html`，双开浏览器模拟两人对战：
    - 两个上下文分别加入同一房间
    - 检查双方界面同步

知识点：

- Playwright 基本 API：
  - `page.goto(url)`、`page.click(selector)`、`page.waitForSelector(selector)`
  - 多上下文/多页面的管理
- 与本地 server 配合：
  - 测试前确保：
    - `node battle-server.js` 已启动
    - `node simple-http-server.js 8080` 已启动

命令示例（具体以项目 `package.json` 为准）：

```bash
cd "pokemmo myself"
npm run e2e
```

---

## 3. Lint 与统一代码风格

### 3.1 ESLint 配置

项目为 JS 代码配置了 ESLint：

- 目的：
  - 统一代码风格（缩进、引号、分号、命名等）
  - 捕获潜在错误（未使用变量、未处理的 Promise 等）
- 典型配置项：
  - `env`：`browser` / `node` / `es2022`
  - `extends`：如 `eslint:recommended`
  - `rules`：根据团队习惯设置

命令示例：

```bash
cd "pokemmo myself"
npm run lint
```

知识点：

- Lint 与 Format 的区别：
  - Lint：发现问题
  - Format：自动修改格式（可结合 Prettier）
- 在 CI 中加入 Lint 步骤，可以防止“风格回退”

---

## 4. CI 思路：GitHub Actions 工作流

> 仓库中可配置 `.github/workflows/*.yml` 作为 CI 工作流，这里给出设计思路与典型步骤。

### 4.1 典型 CI 流程

针对每次 push / PR：

1. Checkout 代码
2. 安装依赖：
   - 根目录 `npm install`
   - `poke-proxy-server` 目录 `npm install`
3. 运行资源脚本与校验：
   - `npm run build:manifest`
   - `npm run check:assets`（若有）
4. 运行 Lint：
   - `npm run lint`
5. 运行测试：
   - `npm test`（Jest）
   - 可选：`npm run e2e`（Playwright，通常在单独 job 或夜间跑）
6. 可选：生成覆盖率报告 / 构建产物

知识点：

- GitHub Actions 基础：
  - `on: [push, pull_request]`
  - `jobs: build: steps: ...`
  - 使用 `actions/setup-node` 选择 Node 版本
- CI 中对 E2E 测试的取舍：
  - 时间与稳定性 vs 覆盖率
  - 可以只在主分支或特定标签触发 E2E

---

## 5. 体积检查与性能预算

### 5.1 体积阈值脚本

为了避免资源/打包体积失控，可以编写脚本：

- 扫描指定目录（如 `data/sprites` 或未来的打包产物目录）
- 汇总文件总大小
- 与预设阈值比较（例如 200MB 或 50MB）
- 如果超出：
  - 在控制台打印详细报告（哪个子目录增长最多）
  - 退出码非 0，阻止 CI 通过

知识点：

- “性能预算”（performance budget）概念：
  - 把性能指标（如首屏 JS 体积、图片体积）当作预算来管理
  - 超预算就是构建失败，而不是“上线后再调”

### 5.2 结合 CI 使用

在 CI 流程中的某一步：

```yaml
- name: Check bundle size
  run: npm run check:bundle
```

这样，当某次提交引入大量新资源时，会立即在 PR 上反馈，而不是等到体验变差之后才发现。

---

## 6. 端到端视角：从提交到“安全上线”

1. 开发者本地完成修改：
   - 跑 `npm run lint`、`npm test`、必要时 `npm run e2e`
2. 提交并推送到远程：
   - 触发 GitHub Actions 工作流
3. CI 流程运行：
   - 安装依赖
   - 生成并校验资源 Manifest
   - Lint + Jest 测试
   - 体积检查
   - 可选：E2E 测试、构建前端产物
4. CI 全绿：
   - 允许合并到主分支
5. 部署（本项目主要面向本地/小范围分享，可手动部署）：
   - 同步仓库到目标机器
   - 按《部署和分享指南》启动后端与前端 server

知识点：

- “左移”（shift left）：尽量在开发和 CI 阶段发现问题
- 把脚本与标准固化在 `package.json` 和 CI 配置中，而不是靠口头约定

---

## 7. 建议的学习和实践路径

1. **先理解脚本入口**：
   - 阅读 `package.json` 中的 `scripts`
   - 尝试分别执行：`npm run build:manifest`、`npm run lint`、`npm test`
2. **再看资源脚本实现**：
   - 从头读 `tools/manifest/*.js`，理解目录遍历、key 规则设计
3. **添加一个小测试**：
   - 给 `RoomManager` 新增一个边界用例，并运行 Jest
4. **写一条体积检查规则**：
   - 为某个资源子目录设置一个小阈值，制造一次“构建失败”，体验一下 CI 的反馈
5. **最后阅读 CI 配置（若存在）**：
   - 对照本篇的流程，理解各步骤如何串联

> 下一篇《学习系列 05｜可观测性与运维实践》将系统介绍日志、指标、健康检查与诊断端点，帮助你从“工程完备性”走向“可运维性”。  


