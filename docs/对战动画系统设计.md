# 对战动画系统设计方案

## 1. 目标

- 提升对战过程的沉浸感与可读性。
- 通过动画反馈突出关键事件（登场、攻击、受击、状态变化等）。
- 保持性能可控，提供关闭/简化选项，兼容低性能设备。

## 2. 动画类型

| 场景 | 动画效果 | 说明 |
| --- | --- | --- |
| 宝可梦登场 / 退场 | 滑入 / 渐隐、缩放 | 区分我方（自左下滑入）与对手（自右上滑入） |
| 技能释放 | 通用能量波 + 类型特效（火焰、电弧等） | 优先实现 4~5 种通用类型分组，可按 move.type 映射 |
| 受击反馈 | HP 条平滑减少、卡片震动、受击闪烁 | 结合 `|-damage|`、`|-heal|` 协议驱动 |
| 异常状态 | 状态徽章脉冲、提示浮层 | 灼烧冒烟、麻痹电流、睡眠泡泡等 |
| 回合提示 | 顶部回合数渐显 | 与日志同步 |
| 天气 / 场地 | 背景叠加特效层 | 可选，后续迭代 |

## 3. 架构设计

### 3.1 模块划分

```
packages/battle-engine/src/animations/
├── AnimationManager.js   // 动画调度与队列控制
├── EffectRenderer.js     // DOM/CSS/GPU 动画实现
├── timelines/
│   ├── MoveTimeline.js   // 技能播放流程
│   ├── SwitchTimeline.js // 登场流程
│   └── StatusTimeline.js // 状态提示流程
└── presets/
    ├── typeEffects.js    // 按属性映射到特效配置
    └── easing.js         // 缓动、持续时长等常量
```

### 3.2 数据驱动

- `AnimationManager.play(eventType, payload)` 为统一入口，外部仅需传递协议解析结果。
- `payload` 示例：
  ```json
  {
    "type": "move",
    "attacker": "p1a: Greninja",
    "target": "p2a: Charizard",
    "moveId": "hydropump",
    "isCritical": false
  }
  ```
- 管理器根据类型选择对应 Timeline，内部再调用 `EffectRenderer` 更新 DOM。

### 3.3 队列与降级

- 同一时间仅播放一个“主动画”（技能/登场），其间允许 HUD（HP 条）动画并行。
- 队列按协议顺序推进，提供 `skip()` 能力（例如快速模式）。
- `AnimationManager` 维护 `settings`：
  - `enabled`: 总开关
  - `speed`: 0.5x / 1x / 1.5x
  - `quality`: high / medium / low（控制粒子效果）

## 4. 接入流程

1. **基础设施搭建**
   - 新增动画目录与管理器骨架（已迁移至 `packages/battle-engine/src/animations`）。
   - 在 `BattleUI` 初始化时创建 `AnimationManager`，并暴露控制面板入口（设置菜单）。

2. **事件绑定**
   - 在 `BattlePhase` 中解析 `|switch|`, `|move|`, `|-damage|`, `|-status|` 等协议，向 `AnimationManager` 派发事件。
   - `AnimationManager` 与 UI 元素解耦，仅接收必要的 DOM 句柄（如精灵容器、HP 条元素）。

3. **动画实现顺序**
   1. 登场/退场动画
   2. HP 条平滑动画 + 卡片震动
   3. 技能通用特效（含命中/未命中反馈）
   4. 异常状态提示
   5. 扩展：天气、场地、特定种族专属动画（可迭代）

4. **配置与存储**
   - 在 `localStorage` 存储玩家的动画偏好。
   - 提供 UI 开关（例如在主界面“设置”弹窗），支持临时禁用动画（移动端/低性能场景）。

## 5. 性能与兼容性

- **性能策略**
  - 尽量使用 GPU 加速（CSS transform/opacity）。
  - 大量特效使用 Canvas/WebGL 需延后规划，首阶段以 CSS + SVG 特效为主。
  - 限制粒子数量，可根据 `quality` 配置调整。
  - 将 `AnimationManager` 的播放耗时上报给 `PerformanceMonitor.recordUIRenderTime('animation', duration)`，便于 `/api/metrics` 分析。
- **兼容策略**
  - 检测 `prefers-reduced-motion`，自动降级或关闭动画。
  - 在动画执行期间仍允许用户发出操作指令（不阻塞输入）。
  - 提供 `AnimationManager.flush()` 用于快速跳过动画（例如调试或网络延迟时）。

## 6. 迭代规划

| 阶段 | 目标 | 产出 |
| --- | --- | --- |
| v1 | 核心框架 + 登场/HP 动画 | AnimationManager + 基础特效 |
| v2 | 技能特效（按属性分类） | 火/水/电/草/一般特效 |
| v3 | 状态/天气/场地动画 | 状态徽章动效 + 背景层 |
| v4 | 高级特效与自定义 | 用户可自定义配色、粒子效果 |

---

该方案可在不影响现有逻辑的前提下逐步引入动画效果，并为未来的特效扩展与性能优化预留足够空间。***

